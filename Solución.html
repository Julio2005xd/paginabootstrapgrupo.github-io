<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Solución del modelo</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
  </head>
  <body>

    <!--Inicio Barra lateral-->
    <div class="d-flex flex-sm-column flex-row flex-nowrap bg-light align-items-center sticky-top position-fixed top-0 start-0">
      <ul class="nav nav-pills nav-flush flex-column mb-auto text-center ">
        <a href="index.html" class="d-block p-3 link-body-emphasis text-decoration-none" title="Icon-only" data-bs-toggle="tooltip" data-bs-placement="right">
          <svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" fill="currentColor" class="bi bi-house-door" viewBox="0 0 16 16">
            <path d="M8.354 1.146a.5.5 0 0 0-.708 0l-6 6A.5.5 0 0 0 1.5 7.5v7a.5.5 0 0 0 .5.5h4.5a.5.5 0 0 0 .5-.5v-4h2v4a.5.5 0 0 0 .5.5H14a.5.5 0 0 0 .5-.5v-7a.5.5 0 0 0-.146-.354L13 5.793V2.5a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5v1.293zM2.5 14V7.707l5.5-5.5 5.5 5.5V14H10v-4a.5.5 0 0 0-.5-.5h-3a.5.5 0 0 0-.5.5v4z"/>
          </svg>
        </a>
        
      <div class="dropend border-top">
        <a href="#" class="d-flex align-items-center justify-content-center p-3 link-body-emphasis text-decoration-none" data-bs-toggle="dropdown" aria-expanded="false">
          <svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" fill="currentColor" class="bi bi-inboxes" viewBox="0 0 16 16">
  <path d="M4.98 1a.5.5 0 0 0-.39.188L1.54 5H6a.5.5 0 0 1 .5.5 1.5 1.5 0 0 0 3 0A.5.5 0 0 1 10 5h4.46l-3.05-3.812A.5.5 0 0 0 11.02 1zm9.954 5H10.45a2.5 2.5 0 0 1-4.9 0H1.066l.32 2.562A.5.5 0 0 0 1.884 9h12.234a.5.5 0 0 0 .496-.438zM3.809.563A1.5 1.5 0 0 1 4.981 0h6.038a1.5 1.5 0 0 1 1.172.563l3.7 4.625a.5.5 0 0 1 .105.374l-.39 3.124A1.5 1.5 0 0 1 14.117 10H1.883A1.5 1.5 0 0 1 .394 8.686l-.39-3.124a.5.5 0 0 1 .106-.374zM.125 11.17A.5.5 0 0 1 .5 11H6a.5.5 0 0 1 .5.5 1.5 1.5 0 0 0 3 0 .5.5 0 0 1 .5-.5h5.5a.5.5 0 0 1 .496.562l-.39 3.124A1.5 1.5 0 0 1 14.117 16H1.883a1.5 1.5 0 0 1-1.489-1.314l-.39-3.124a.5.5 0 0 1 .121-.393zm.941.83.32 2.562a.5.5 0 0 0 .497.438h12.234a.5.5 0 0 0 .496-.438l.32-2.562H10.45a2.5 2.5 0 0 1-4.9 0z"/>
</svg>
        </a>
        <ul class="dropdown-menu text-small shadow">
          <li><a class="dropdown-item rounded-2" href="Definicion.html">1. Definición Y Historia</a></li>
                    <li><a class="dropdown-item rounded-2" href="Ciencias.html">2. Ciencias en la que se aplica la TGS</a></li>
                    <li><a class="dropdown-item rounded-2" href="AnalisisSistemico.html">3. Análisis sistémico</a></li>
                    <li><a class="dropdown-item rounded-2" href="Metodologia.html">4. Metodología de la investigación de operaciones según la TGS</a></li>
                    <li><a class="dropdown-item rounded-2" href="Formulacion.html">5. Formulación y definición del modelo</a></li>
                    <li><a class="dropdown-item rounded-2" href="Construcción.html">6. Construcción del modelo </a></li>
                    <li><a class="dropdown-item rounded-2" href="Solución.html">7. Solución del modelo </a></li>
                    <li><a class="dropdown-item rounded-2" href="Validación.html">8. Validación del modelo</a></li>
                    <li><a class="dropdown-item rounded-2" href="Implementación.html">9. Implementación de resultados</a></li>
                    <li><a class="dropdown-item rounded-2" href="Metodos.html">10. Métodos de la investigación de operaciones según la TGS</a></li>
                    <li><a class="dropdown-item rounded-2" href="Tipos.html">11. Tipos de los modelos matemáticos</a></li>
                    <li><a class="dropdown-item rounded-2" href="Inconvenientes.html">12. Inconvenientes </a></li>
                </ul>
      <a href="Referencias.html" class="d-block p-3 link-body-emphasis text-decoration-none" title="Icon-only" data-bs-toggle="tooltip" data-bs-placement="right">
        <svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" fill="currentColor" class="bi bi-search" viewBox="0 0 16 16">
          <path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001q.044.06.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1 1 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0"/>
        </svg>
      </a>
      <a href="https://buscapalabras.com.ar/sopa-de-letras-de-investigacion-de-operaciones_22.html" class="d-block p-3 link-body-emphasis text-decoration-none" title="Icon-only" data-bs-toggle="tooltip" data-bs-placement="right">
        <svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" fill="currentColor" class="bi bi-dpad" viewBox="0 0 16 16">
          <path d="m7.788 2.34-.799 1.278A.25.25 0 0 0 7.201 4h1.598a.25.25 0 0 0 .212-.382l-.799-1.279a.25.25 0 0 0-.424 0Zm0 11.32-.799-1.277A.25.25 0 0 1 7.201 12h1.598a.25.25 0 0 1 .212.383l-.799 1.278a.25.25 0 0 1-.424 0ZM3.617 9.01 2.34 8.213a.25.25 0 0 1 0-.424l1.278-.799A.25.25 0 0 1 4 7.201V8.8a.25.25 0 0 1-.383.212Zm10.043-.798-1.277.799A.25.25 0 0 1 12 8.799V7.2a.25.25 0 0 1 .383-.212l1.278.799a.25.25 0 0 1 0 .424Z"/>
          <path d="M6.5 0A1.5 1.5 0 0 0 5 1.5v3a.5.5 0 0 1-.5.5h-3A1.5 1.5 0 0 0 0 6.5v3A1.5 1.5 0 0 0 1.5 11h3a.5.5 0 0 1 .5.5v3A1.5 1.5 0 0 0 6.5 16h3a1.5 1.5 0 0 0 1.5-1.5v-3a.5.5 0 0 1 .5-.5h3A1.5 1.5 0 0 0 16 9.5v-3A1.5 1.5 0 0 0 14.5 5h-3a.5.5 0 0 1-.5-.5v-3A1.5 1.5 0 0 0 9.5 0zM6 1.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v3A1.5 1.5 0 0 0 11.5 6h3a.5.5 0 0 1 .5.5v3a.5.5 0 0 1-.5.5h-3a1.5 1.5 0 0 0-1.5 1.5v3a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-3A1.5 1.5 0 0 0 4.5 10h-3a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1 .5-.5h3A1.5 1.5 0 0 0 6 4.5z"/>
        </svg>
      </a>
    </div>
  </ul>
</div>
<!--Fin Barra lateral-->
    <div class="container">
  <div class="px-5 pt-5 my-5 text-right border-bottom">
    <h1 class="display-4 fw-bold text-body-emphasis">Solución del modelo</h1>
    <div class="col-lg-12 mx-auto">
      <p class="lead mb-4">Es la fase de desarrollo de procedimientos basado en computadora para obtener soluciones a partir de modelos 
        matemáticos en un estudio de Investigación de Operaciones (IO). Se destaca que, si bien esta fase es importante, no es 
        necesariamente la más crucial del estudio. Se aplica uno de los algoritmos estándar (procedimientos de solución sistemática) 
        de IO en una computadora utilizando uno de los numerosos paquetes de software disponibles. Para los profesionales experimentados 
        en IO, encontrar una solución es la parte divertida del proceso, mientras que el verdadero trabajo se encuentra en los pasos 
        anteriores y posteriores, como el análisis de post optimalidad.

        Se centra en cómo obtener soluciones para diferentes tipos de modelos matemáticos, pero se enfatiza que estas soluciones son óptimas 
        sólo con respecto al modelo utilizado. No se puede garantizar que la solución óptima para el modelo sea la mejor para el problema 
        real, debido a las incertidumbres asociadas con los problemas reales.

        En lugar de soluciones perfectas, se sugiere que el éxito de un estudio de buscar IO debe evaluarse en términos de si proporciona una 
        guía mejor para la acción que otros medios disponibles. 
</p> 
      </div>
      <ul>
<div class="col-lg-12 mx-auto"> 
      <p class="lead mb-6">  <li><h4>Formulación Y Solución De Modelos De Programación Lineal En Una Hoja De Cálculo: </h4></li>Los 
  paquetes de hojas de cálculo, como Excel, son una herramienta conocida para analizar y resolver problemas pequeños de programación 
  lineal. Es sencillo introducir en una hoja de cálculo las características principales de un modelo de programación lineal, entre ellas,
  todos sus parámetros. Sin embargo, este software puede hacer mucho más que sólo desplegar datos. Si se incluye cierta información 
  adicional, la hoja de cálculo se puede usar para analizar con rapidez soluciones potenciales. 
  El Excel Solver puede aplicar el método símplex para encontrar una solución óptima para el modelo.
        </p>
    </div>

        <div class="col-lg-12 mx-auto">  
      <p class="lead mb-6"><li><h4>Solución de problemas de programación lineal: </h4></li>método símplex Es el momento de comenzar 
        a estudiar el método símplex, un procedimiento general para resolver problemas de programación lineal. Desarrollado por George 
        Dantzig en 1947, se ha comprobado su extraordinaria eficiencia, y se usa en forma rutinaria para resolver problemas grandes en 
        las computadoras de hoy en día. Excepto en el caso de problemas muy pequeños, se ejecuta siempre en una computadora y existe una 
        amplia variedad de paquetes complejos de software para ello. También se usan extensiones y variaciones del método símplex para 
        realizar análisis post óptimo (que incluye el análisis de sensibilidad) del modelo. 

        Procedimientos de solución de problemas de asignación Se dispone de procedimientos alternativos de solución para resolver aquellos que 
        no son mucho más grandes. Se pueden resolver con rapidez mediante el método símplex general, y quizá sea conveniente usar un 
        paquete básico como Excel y su Solver que utilice este método. los problemas de asignación grandes se pueden resolver mucho más 
        rápido si se usan procedimientos de solución más específicos. 
        </p>
    </div>

        <div class="col-lg-12 mx-auto">  
      <p class="lead mb-6"><li><h4>Algunas Perspectivas Acerca De La Solución De Problemas De Programación Entera: </h4></li>
          Puede parecer que la solución de problemas de PE es sencilla. Después de todo, los problemas de programación lineal se 
          pueden resolver en forma eficiente, y la única diferencia es que la PE tiene muchas menos soluciones que considerar. 
          En realidad, se garantiza que los problemas de PE pura con región factible acotada tengan sólo un número finito de soluciones 
          factibles. Desafortunadamente, existen dos falacias en esta línea de razonamiento. 

          Una es que tener un número finito de soluciones factibles asegura que el problema se puede resolver. Los números finitos 
          pueden ser astronómicamente grandes. Por ejemplo, Si se tienen n variables, existen 2n soluciones que considerar. 
          En consecuencia, cada vez que no aumenta en 1, el número de soluciones se duplica. Este patrón se llama crecimiento 
          exponencial de la dificultad del problema. Con n 510, existen más de mil soluciones (1024); en razón de ello, aun las 
          computadoras más eficientes son incapaces de realizar una enumeración exhaustiva que verifique la factibilidad de cada 
          solución y, de ser factible, que calcule el valor de la función objetivo en problemas de PEB con unas cuantas docenas de 
          variables, sin mencionar los problemas de PE general con el mismo número de variables enteras. Por fortuna, empezando con 
          las ideas que se describirán en secciones subsecuentes, en la actualidad los mejores algoritmos de PE son ampliamente 
          superiores al método de la enumeración exhaustiva. La mejora en las dos décadas pasadas ha sido sorprendente. En la actualidad 
          pueden resolverse en segundos mediante el uso de paquetes de software comerciales (como, por ejemplo, el paquete CPLEX). 
          Este aumento dramático en la velocidad se debe al enorme progreso en tres áreas: mejoras significativas en los algoritmos (así como en otros algoritmos de PE), mejoras sorprendentes en algoritmos de programación lineal muy utilizados en los algoritmos de programación entera y el notable incremento de la velocidad de las computadoras (entre las cuales se incluyen las de escritorio). Como consecuencia de todo ello, una gran cantidad de problemas de gran tamaño están siendo resueltos en la actualidad, lo que hubiera sido imposible en las décadas pasadas. Los mejores algoritmos de hoy en día son capaces de resolver algunos problemas PEB (Plan de Ejecución BIM) puros con cientos de miles de variables. Sin embargo, debido al crecimiento exponencial, ni los mejores algoritmos garantizan la solución de todos los problemas relativamente pequeños (con menos de 100 variables binarias o enteras). Según sus características, ciertos problemas pequeños pueden ser más difíciles de resolver que algunos más grandes. Cuando se trata con variables enteras generales en lugar de variables binarias, el tamaño de los problemas que pueden resolverse tiende a ser mucho más pequeño. Sin embargo, hay excepciones. Por ejemplo, hace varios años, la versión profesional de CPLEX 8.0 resolvió de manera exitosa un problema de PE con 215 mil variables enteras generales, 75 mil restricciones funcionales y 6 millones de coeficientes de restricción distintos de cero. Con todo, las versiones más actuales de CPLEX son mucho más poderosas. La segunda falacia es que si se eliminan algunas soluciones factibles (las no enteras) de un problema de programación lineal, será más fácil resolverlo. Por el contrario, sólo cuando todas estas soluciones factibles están ahí, se puede garantizar que existe una solución factible en el vértice (FEV) [y por ende la solución básica factible (BF) correspondiente] que es óptima para el problema completo. Esta garantía es la clave de la extraordinaria eficiencia del método símplex. Como resultado, en general es mucho más sencillo resolver los problemas de programación lineal que los de programación entera. Es lógico, entonces, que la mayor parte de los algoritmos exitosos de programación entera incorporan un algoritmo de programación lineal, como el método símplex (o el método símplex dual) lo más que puedan, y que relacionen partes del problema de PE bajo consideración con el problema correspondiente de programación lineal (es decir, el mismo problema con la restricción de valores enteros eliminada). En cualquier problema dado de PE, el problema correspondiente de programación lineal se conoce como su relajamiento de PL. El algoritmo que se presenta en las dos secciones siguientes ilustra cómo se puede usar una sucesión de relajamientos de PL para

          porciones de un problema de programación entera, con objeto de resolver de manera eficaz un problema completo de PE. Existe 
          una situación especial en la que no es más difícil resolver el problema de PE que resolver una vez su relajamiento de PL al 
          aplicar el método símplex; en este caso, la solución del relajamiento de PL satisface la restricción de valores enteros del 
          problema de PE. Cuando ocurre esto, la solución también debe ser óptima para el problema de PE, puesto que se trata de la 
          mejor solución entre todas las soluciones factibles del relajamiento de PL, que incluyen todas las soluciones factibles del 
          problema de PE. Entonces, es normal que un algoritmo de programación entera comience con la aplicación del método símplex a 
          su relajamiento de PL, para verificar si tiene lugar este acontecimiento fortuito. Aunque, sin duda, casi siempre es accidental que la solución óptima del relajamiento de PL sea entera, en realidad existen varios tipos especiales de problemas de PE para los que este resultado se puede garantizar. Se pueden manejar como problemas de programación lineal, puesto que se pueden resolver por completo al aplicar las versiones simplificadas del método símplex. Aunque toda esta simplificación no es usual, con frecuencia los problemas de PE que surgen en la práctica tienen alguna estructura especial que se puede aprovechar para simplificarlos. A veces se pueden resolver con éxito versiones muy grandes de estos problemas. Cada vez son más importantes los algoritmos especiales diseñados específicamente para explotar ciertos tipos de estructuras especiales de programación entera. En consecuencia, los tres factores determinantes de la dificultad computacional de un problema de PE son :
</p>
    </div>

        <div class="col-lg-12 mx-auto">  
      <p class="lead mb-6"><li><h4>1). </h4></li> El número de variables enteras.
        </p> 
    </div>

        <div class="col-lg-12 mx-auto">  
      <p class="lead mb-6"><li><h4>2). </h4></li> Si las variables enteras son binarias o generales. 
        </p> 
    </div>
       <div class="col-lg-12 mx-auto">  
      <p class="lead mb-6"><li><h4>3). </h4></li> Estructura especial del problema. 
        </p> 
    </div>
      </ul>
     <div class="col-lg-12 mx-auto">  
      <p class="lead mb-6"> Esta situación es opuesta a la de programación lineal, en donde el número de restricciones (funcionales) es mucho más importante que el número de variables. En programación entera, el número de restricciones tiene alguna importancia en especial si se van a resolver los relajamientos de PL, pero es estrictamente secundario en el caso de los otros tres factores. En realidad, existen casos en los que aumentar el número de restricciones disminuye el tiempo de cálculo, puesto que se reduce el número de soluciones factibles. En los problemas de PEM es el número de variables enteras y no el número total de variables lo que es importante, pues las variables continuas casi no tienen efecto sobre el esfuerzo computacional. Debido a que, en general, es mucho más difícil resolver los problemas de PE que los de programación lineal, a veces es tentador usar el procedimiento aproximado y aplicar el método símplex al relajamiento de PL y después redondear los valores no enteros a enteros en la solución que se obtuvo. Este enfoque puede ser adecuado en algunas aplicaciones, en especial si los valores de las variables son tan grandes que el redondeo introduce un error muy pequeño; sin embargo, debe tenerse cuidado al poner en práctica este procedimiento, pues se corren dos riesgos. Una desventaja es que una solución óptima de programación lineal no necesariamente es factible después de redondear. Con frecuencia es difícil decidir en qué sentido redondear para conservar la factibilidad. Incluso, 
        podría ser necesario cambiar el valor de algunas variables en una o más unidades después de redondear.
        </p> 
        </div>
    
    <div class="overflow-hidden" style="max-height: 720px;">
      <div class="container px-5">
        <img src="img/Carrusel7.jpg" class="img-fluid ">
      </div>
    </div><br>
  </div>
</div> 
<footer class="container">
  <p class="float-end border-bottom btn btn-outline-secondary text-decoration-none"><a href="#">Volver a arriba</a></p>
  <p>&copy; 2024 Julio Cesar Hernández Monroy / Yulieth Natalia Quiroga Alape / Keizy Lizeth Cuadrado Amado</p>
</footer>
</body>
</html>
